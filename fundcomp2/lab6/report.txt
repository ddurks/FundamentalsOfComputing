David Durkin
Fund Comp II
Lab 6 Report

	 The user uses the program by simply running the program and then typing in the
name of the file that contains the puzzle.

	Internally, this program works by first in the constructor reading in all of the
values from the text file into a three dimensional array, this is done using a series of temporary vectors and values along with a series of push_back() calls. Then the original puzzle is displayed utilizing this newly created vector. Next, there is a call to the solve function which incorporates all of the other functions in the class. In addition to the display function, there are seven others. The didSolve() function loops through the entire puzzle and returns a 1, or true if there are no longer any zeros. The removePossible() function removes all possible values form any non-open indexes, making a call to the removePossibleAt() function which checks the row, column, and small square groups. There are also the elimination() function and the singleton() function. These are the two solving algorithms which were required. The elimination algorithm simply iterates through the array, and if an index combination is currently a 0, it loops through the possible values at that position, if there is only one remaining possible value, it simply substitutes that value for the zero. The singleton algorithm is a bit more complicated. It loops through the board and determines if an index combination is open as well, but it then cycles through the possible values and for each value that is a possibility and checks to determine if that value is a singleton(is the only instance in the entire row where said value is possible). If a singleton is found, then it sets the index to the singleton value. There is a call to the isSingleton() function in this algorithm, which checks and compares the possible values of the current index to with the possible values of all the other indexes in the row. Finally, the solve() function combines all these functions into a simple algorithm. First it calls removePossible to update the indexes, and then, while the puzzle has not been solved(didSolve()), it runs the elimination algorithm and then the singleton algorithm upon the elimination algorithm not being sufficient. I found that what worked the best was running both of the algorithms one after the other.

	I was able to verify that this program is correct by simply feeding it the 
sudoku puzzles which were provided, and determining whether a solution is found. My algorithm was able to solve all the puzzles in my testing.